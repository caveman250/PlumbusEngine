// This C++ shader is autogenerated by spirv-cross.
#include "spirv_cross/internal_interface.hpp"
#include "spirv_cross/external_interface.h"
#include <array>
#include <stdint.h>

using namespace spirv_cross;
using namespace glm;

namespace Impl
{
    struct Shader
    {
        struct PointLight
        {
            vec4 position;
            vec3 color;
            float radius;
        };
        
        struct DirectionalLight
        {
            vec3 color;
            vec3 direction;
        };
        
        struct Resources : FragmentResources
        {
            struct UBO
            {
                vec4 viewPos;
                std::array<struct PointLight, 6> pointLights;
                std::array<struct DirectionalLight, 1> directionalLights;
            };
            
            internal::Resource<UBO> ubo__;
#define ubo __res->ubo__.get()
            
            internal::StageInput<vec2> inUV__;
#define inUV __res->inUV__.get()
            
            internal::StageOutput<vec4> outFragcolor__;
#define outFragcolor __res->outFragcolor__.get()
            
            internal::Resource<sampler2D> samplerposition__;
#define samplerposition __res->samplerposition__.get()
            
            internal::Resource<sampler2D> samplerNormal__;
#define samplerNormal __res->samplerNormal__.get()
            
            internal::Resource<sampler2D> samplerAlbedo__;
#define samplerAlbedo __res->samplerAlbedo__.get()
            
            inline void init(spirv_cross_shader& s)
            {
                FragmentResources::init(s);
                s.register_resource(ubo__, 0, 4);
                s.register_stage_input(inUV__, 0);
                s.register_stage_output(outFragcolor__, 0);
                s.register_resource(samplerposition__, 0, 1);
                s.register_resource(samplerNormal__, 0, 2);
                s.register_resource(samplerAlbedo__, 0, 3);
            }
        };
        
        Resources* __res;
        
        inline void main()
        {
            vec3 fragPos = texture(samplerposition, inUV).xyz();
            vec3 normal = texture(samplerNormal, inUV).xyz();
            vec4 albedo = texture(samplerAlbedo, inUV);
            vec3 fragcolor = albedo.xyz() * 0.100000001490116119384765625f;
            for (int32_t i = 0; i < 6; i++)
            {
                vec3 L = ubo.pointLights[i].position.xyz() - fragPos;
                float dist = length(L);
                vec3 V = ubo.viewPos.xyz() - fragPos;
                V = normalize(V);
                L = normalize(L);
                float atten = ubo.pointLights[i].radius / (pow(dist, 2.0f) + 1.0f);
                vec3 N = normalize(normal);
                float NdotL = max(0.0f, dot(N, L));
                vec3 diff = ((ubo.pointLights[i].color * albedo.xyz()) * NdotL) * atten;
                vec3 R = reflect(-L, N);
                float NdotR = max(0.0f, dot(R, V));
                vec3 spec = ((ubo.pointLights[i].color * albedo.w) * pow(NdotR, 16.0f)) * atten;
                fragcolor += (diff + spec);
            }
            for (int32_t i_1 = 0; i_1 < 1; i_1++)
            {
                vec3 L_1 = normalize(ubo.directionalLights[i_1].direction);
                vec3 N_1 = normalize(normal);
                float NdotL_1 = max(0.0f, dot(N_1, L_1));
                vec3 diff_1 = (ubo.directionalLights[i_1].color * albedo.xyz()) * NdotL_1;
                vec3 R_1 = reflect(-L_1, N_1);
                vec3 V_1 = ubo.viewPos.xyz() - fragPos;
                V_1 = normalize(V_1);
                float NdotR_1 = max(0.0f, dot(R_1, V_1));
                vec3 spec_1 = (ubo.directionalLights[i_1].color * albedo.w) * pow(NdotR_1, 16.0f);
                fragcolor += (diff_1 + spec_1);
            }
            outFragcolor = vec4(fragcolor, 1.0f);
        }
        
    };
}

spirv_cross_shader_t *spirv_cross_construct(void)
{
    return new FragmentShader<Impl::Shader, Impl::Shader::Resources>();
}

void spirv_cross_destruct(spirv_cross_shader_t *shader)
{
    delete static_cast<FragmentShader<Impl::Shader, Impl::Shader::Resources>*>(shader);
}

void spirv_cross_invoke(spirv_cross_shader_t *shader)
{
    static_cast<FragmentShader<Impl::Shader, Impl::Shader::Resources>*>(shader)->invoke();
}

static const struct spirv_cross_interface vtable =
{
    spirv_cross_construct,
    spirv_cross_destruct,
    spirv_cross_invoke,
};

const struct spirv_cross_interface *spirv_cross_get_interface(void)
{
    return &vtable;
}
